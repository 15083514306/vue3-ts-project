import {
  __dirname
} from "./chunk-33IGY6IS.js";

// src/index.ts
import { createUnplugin } from "unplugin";
import { checkPort, getRandomPort } from "get-port-please";

// src/core/constants.ts
var PLUGIN_NAME = "unplugin-turbo-console";
var NUXT_CONFIG_KEY = "turboConsole";

// src/core/server/index.ts
import { createServer } from "http";
import { cwd } from "process";
import { resolve as resolve2 } from "pathe";
import { createApp, eventHandler, fromNodeMiddleware, getQuery, toNodeListener } from "h3";
import serveStatic from "serve-static";
import launch from "launch-editor";

// src/core/dir.ts
import { fileURLToPath } from "url";
import { dirname, resolve } from "pathe";
var DIR_DIST = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
var DIR_CLIENT = resolve(DIR_DIST, "./client/index.html");
var DIR_INTRO = resolve(DIR_DIST, "./client/intro.html");

// src/core/server/index.ts
async function startServer(port = 3070) {
  try {
    await fetch(`http://localhost:${port}/health`);
  } catch (error) {
    const app = createApp();
    app.use("/client", fromNodeMiddleware(serveStatic(DIR_CLIENT)));
    app.use("/intro", fromNodeMiddleware(serveStatic(DIR_INTRO)));
    app.use("/health", eventHandler(() => {
      return {
        message: "ok"
      };
    }));
    app.use("/__open-in-editor", eventHandler(async (event) => {
      try {
        const { file } = getQuery(event);
        launch(resolve2(cwd(), file));
        return {
          message: "ok"
        };
      } catch (error2) {
        return {
          error: String(error2)
        };
      }
    }));
    createServer(toNodeListener(app)).listen(port);
  }
}

// src/core/transform/vite.ts
import MagicString from "magic-string";
import { babelParse, getLang, walkAST } from "ast-kit";
import { SourceMapConsumer } from "source-map-js";

// src/core/transform/common.ts
import { cwd as cwd2 } from "process";
import { Buffer } from "buffer";
import { extname, relative } from "pathe";

// src/core/utils.ts
import { sep } from "pathe";
import { createFilter } from "@rollup/pluginutils";
var filter = createFilter(
  [/\.vue$/, /\.vue\?vue/, /\.vue\?v=/, /\.ts$/, /\.tsx$/, /\.js$/, /\.jsx$/, /\.svelte$/],
  [/[\\/]node_modules[\\/]/, /[\\/]\.git[\\/]/, /[\\/]\.nuxt[\\/]/]
);
var commonStyle = "padding:2px 5px; border-radius:3px 0 0 3px;margin-bottom:5px;";
var consoleStyles = {
  ".js": `${commonStyle}color: #111827; background: #F7DF1E`,
  ".jsx": `${commonStyle}color: #111827; background: #F7DF1E`,
  ".ts": `${commonStyle}color: #fff; background: #3178C6`,
  ".tsx": `${commonStyle}color: #fff; background: #3178C6`,
  ".vue": `${commonStyle}color: #fff; background: #4FC08D`,
  ".svelte": `${commonStyle}color: #fff; background: #FF3E00`,
  ".astro": `${commonStyle}color: #fff; background: #FF5D01`,
  "default": `${commonStyle}color: #111827; background: #F7DF1E`
};
function getConsoleStyle(fileType) {
  return consoleStyles[fileType] ?? consoleStyles.default;
}
var launchEditorStyle = "background: #00DC8250;padding:2px 5px;border-radius:0 3px 3px 0;margin-bottom:5px";
var getEnforce = {
  rollup: "post",
  vite: "post",
  webpack: "pre",
  esbuild: "post",
  rspack: "pre"
};
function printInfo(port) {
  console.log("\x1B[32m%s\x1B[0m\x1B[1m%s\x1B[0m\x1B[36m%s\x1B[0m", "  \u279C", `  TurboConsole:`, ` http://localhost:${port}/intro`);
}
function getFileNameWithoutExtension(fileName) {
  if (!fileName)
    return "";
  return fileName.replace(/\.[^/.]+$/, "");
}
function getExtendedPath(filePath, extendedPathFileNames) {
  const arr = filePath.split(sep);
  let basename = arr.pop() || "";
  const basenameWithoutExt = getFileNameWithoutExtension(basename).toLowerCase();
  if (extendedPathFileNames && extendedPathFileNames?.length > 0) {
    let isEnd = false;
    if (extendedPathFileNames.some((name) => basenameWithoutExt === name.toLowerCase())) {
      while (!isEnd) {
        const fileName = arr.pop();
        basename = `${fileName}/${basename}`;
        if (extendedPathFileNames.every((name) => name.toLowerCase() !== fileName?.toLowerCase()))
          isEnd = true;
      }
    }
  }
  return basename;
}

// src/core/transform/common.ts
function genConsoleString(genContext) {
  const { options, originalColumn, originalLine, argType, id } = genContext;
  let { argsName } = genContext;
  const { prefix, suffix, disableLaunchEditor, port, disableHighlight, extendedPathFileNames } = options;
  const _prefix = prefix ? `${prefix}\\n` : "";
  const _suffix = suffix ? `\\n${suffix}` : "";
  const urlObject = new URL(id, "file://");
  const filePath = urlObject.pathname;
  const fileName = getExtendedPath(filePath, extendedPathFileNames);
  const fileType = extname(filePath);
  try {
    argsName = JSON.parse(`"${argsName}"`);
  } catch (error) {
  }
  if (argsName?.length > 30)
    argsName = `${argsName.slice(0, 30)}...`;
  const lineInfo = `%c\u{1F680} ${fileName}\xB7${originalLine}${["StringLiteral", "NumericLiteral"].includes(argType) ? "" : ` ~ ${argsName}`}`;
  const codePosition = `${relative(cwd2(), filePath)}:${originalLine}:${(originalColumn || 0) + 1}`;
  const launchEditorString = `%c\u{1F526} http://localhost:${port}/client#${Buffer.from(codePosition, "utf-8").toString("base64")}`;
  let consoleString = "";
  if (!disableHighlight && !disableHighlight) {
    consoleString = _prefix ? `"${_prefix}${lineInfo}${launchEditorString}","${getConsoleStyle(fileType)}","${launchEditorStyle}","\\n",` : `"${lineInfo}${launchEditorString}","${getConsoleStyle(fileType)}","${launchEditorStyle}","\\n",`;
  }
  if (disableHighlight && !disableLaunchEditor) {
    consoleString = _prefix ? `"${_prefix}${launchEditorString}","${launchEditorStyle}","\\n",` : `"${launchEditorString}","${launchEditorStyle}","\\n",`;
  }
  if (!disableHighlight && disableLaunchEditor) {
    consoleString = _prefix ? `"${_prefix}${lineInfo}","${getConsoleStyle(fileType)}","\\n",` : `"${lineInfo}","${getConsoleStyle(fileType)}","\\n",`;
  }
  if (disableHighlight && disableLaunchEditor) {
    consoleString = _prefix ? `"${_prefix}",` : "";
  }
  return {
    consoleString,
    _suffix
  };
}
function isConsoleExpression(node) {
  return node.type === "CallExpression" && node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "console" && node.callee.property.type === "Identifier" && node.arguments?.length > 0;
}

// src/core/transform/vite.ts
function viteTransform(context) {
  const { code, id, pluginContext, options } = context;
  const magicString = new MagicString(code);
  const program = babelParse(code, getLang(id), {
    sourceFilename: id
  });
  walkAST(program, {
    enter(node) {
      if (isConsoleExpression(node)) {
        const expressionStart = node.start;
        const expressionEnd = node.end;
        const originalExpression = magicString.slice(expressionStart, expressionEnd);
        if (originalExpression.includes("%c"))
          return false;
        const { line, column } = node.loc.start;
        const args = node.arguments;
        const sourceMap = pluginContext.getCombinedSourcemap();
        const consumer = new SourceMapConsumer(sourceMap);
        const { line: originalLine, column: originalColumn } = consumer.originalPositionFor({
          line,
          column
        });
        const argsStart = args[0].start;
        const argsEnd = args[args.length - 1].end;
        const argType = args[0].type;
        const argsName = magicString.slice(argsStart, argsEnd).toString().replace(/`/g, "").replace(/\n/g, "").replace(/"/g, "");
        const { consoleString, _suffix } = genConsoleString({
          options,
          originalLine,
          originalColumn,
          argType,
          argsName,
          id
        });
        consoleString && magicString.appendLeft(argsStart, consoleString);
        _suffix && magicString.appendRight(argsEnd, `,"${_suffix}"`);
      }
    }
  });
  return {
    code: magicString.toString(),
    map: magicString.generateMap({ source: id })
  };
}

// src/core/transform/webpack.ts
import { babelParse as babelParse2, getLang as getLang2, walkAST as walkAST2 } from "ast-kit";
import MagicString2 from "magic-string";
var vuePatterns = [/\.vue$/, /\.vue\?vue/, /\.vue\?v=/];
async function webpackTransform(context) {
  const { id, code, options } = context;
  let scriptString = code;
  let scriptLang = getLang2(context.id);
  let vueSfcLocStart = {
    line: 0,
    column: 0,
    offset: 0
  };
  const magicString = new MagicString2(code);
  if (vuePatterns.some((pattern) => pattern.test(id))) {
    const { parse } = await import("vue/compiler-sfc");
    const { descriptor, errors } = parse(code, {
      filename: id
    });
    if (errors.length === 0) {
      if (descriptor.script) {
        scriptString = descriptor.script.content;
        scriptLang = descriptor.script.lang || "";
        vueSfcLocStart = descriptor.script.loc.start;
      } else if (descriptor.scriptSetup) {
        scriptString = descriptor.scriptSetup.content;
        scriptLang = descriptor.scriptSetup.lang || "";
        vueSfcLocStart = descriptor.scriptSetup.loc.start;
      }
      vueSfcLocStart.line--;
    }
  }
  const program = babelParse2(scriptString, scriptLang, {
    sourceFilename: id
  });
  walkAST2(program, {
    enter(node) {
      if (isConsoleExpression(node)) {
        const expressionStart = node.start;
        const expressionEnd = node.end;
        const originalExpression = magicString.slice(expressionStart, expressionEnd);
        if (originalExpression.includes("%c"))
          return false;
        const { line, column } = node.loc.start;
        const args = node.arguments;
        const argsStart = args[0].start + vueSfcLocStart.offset;
        const argsEnd = args[args.length - 1].end + vueSfcLocStart.offset;
        const argType = args[0].type;
        const argsName = magicString.slice(argsStart, argsEnd).toString().replace(/`/g, "").replace(/\n/g, "").replace(/"/g, "");
        const originalLine = line + vueSfcLocStart.line;
        const originalColumn = column;
        const { consoleString, _suffix } = genConsoleString({
          options,
          originalLine,
          originalColumn,
          argType,
          argsName,
          id
        });
        consoleString && magicString.appendLeft(argsStart, consoleString);
        _suffix && magicString.appendRight(argsEnd, `,"${_suffix}"`);
      }
    }
  });
  return {
    code: magicString.toString(),
    map: magicString.generateMap({ source: id })
  };
}

// src/core/transform/transformer.ts
function transformer(context) {
  const { meta } = context;
  if (["webpack", "rspack"].includes(meta.framework))
    return webpackTransform(context);
  else
    return viteTransform(context);
}

// src/core/options.ts
import { env } from "process";
var DETAULT_OPTIONS = {
  prefix: "",
  suffix: "",
  disableLaunchEditor: false,
  disableHighlight: false,
  extendedPathFileNames: [],
  port: 3070
};
var BUILD_OPTIONS = {
  disableLaunchEditor: true,
  disableHighlight: true
};
function resolveOptions(options) {
  let resolved = {
    ...DETAULT_OPTIONS,
    ...options
  };
  if (env.NODE_ENV === "production") {
    resolved = {
      ...resolved,
      ...BUILD_OPTIONS
    };
  }
  return resolved;
}

// src/index.ts
var unpluginFactory = (rawOptions = {}, meta) => {
  const options = resolveOptions(rawOptions);
  async function detectPort() {
    const isAvailable = await checkPort(options.port);
    if (!isAvailable)
      options.port = await getRandomPort();
  }
  return {
    name: PLUGIN_NAME,
    enforce: getEnforce[meta.framework] || "post",
    transformInclude(id) {
      return filter(id);
    },
    async transform(code, id) {
      const context = {
        options,
        pluginContext: this,
        code,
        id,
        meta
      };
      const result = await transformer(context);
      return result;
    },
    vite: {
      async configureServer(server) {
        if (options.disableLaunchEditor)
          return;
        await detectPort();
        const _print = server.printUrls;
        server.printUrls = () => {
          _print();
          printInfo(options.port);
        };
        startServer(options.port);
      }
    },
    async webpack(compiler) {
      if (options.disableLaunchEditor)
        return;
      await detectPort();
      if (compiler.options.mode === "development") {
        compiler.hooks.done.tap(PLUGIN_NAME, (state) => {
          if (state.hasErrors())
            return;
          printInfo(options.port);
          startServer(options.port);
        });
      }
    },
    async rspack(compiler) {
      if (options.disableLaunchEditor)
        return;
      await detectPort();
      if (compiler.options.mode === "development") {
        compiler.hooks.done.tap(PLUGIN_NAME, (state) => {
          if (state.hasErrors())
            return;
          printInfo(options.port);
          startServer(options.port);
        });
      }
    }
  };
};
var unplugin = /* @__PURE__ */ createUnplugin(unpluginFactory);
var src_default = unplugin;

export {
  PLUGIN_NAME,
  NUXT_CONFIG_KEY,
  unpluginFactory,
  unplugin,
  src_default
};
